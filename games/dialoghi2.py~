import pygame, sys, math

# Inizializzazione di Pygame e del mixer
pygame.init()

# Dimensioni della finestra e FPS
WIDTH, HEIGHT = 1200, 800
FPS = 30

# Caricamento file audio (con gestione degli errori)
audio_available = True
try:
    pygame.mixer.music.load("background_music.mp3")
    pygame.mixer.music.play(-1)
except Exception as e:
    print("Errore nel caricamento di background_music.mp3:", e)
    audio_available = False

try:
    node_sound = pygame.mixer.Sound("node_reached.wav")
except Exception as e:
    print("Errore nel caricamento di node_reached.wav:", e)
    node_sound = None

try:
    tick_sound = pygame.mixer.Sound("tick.wav")
except Exception as e:
    print("Errore nel caricamento di tick.wav:", e)
    tick_sound = None

# Parametri di gioco
MAX_DEGREE = 5         # Non più usato (le connessioni sono fisse per livello)
# Ora il posizionamento non è casuale ma per livelli
margin_x = 200         # margine orizzontale
margin_y_top = 250     # y per il livello 0
margin_y_bottom = 50   # spazio inferiore non usato per i livelli
region_height = HEIGHT - margin_y_top - margin_y_bottom  # altezza disponibile (800-250-50=500)
level_width = WIDTH - 2 * margin_x  # larghezza disponibile per posizionare i nodi

# Impostazione dei colori
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
NEURON_COLOR = (50, 150, 250)
GOAL_COLOR = (250, 100, 100)
TEXT_COLOR = WHITE
BLINK_BASE = (150, 150, 250)

# Colori associati ai tasti (usati nella legenda)
arrow_colors = {
    pygame.K_1: (170, 0, 255),
    pygame.K_2: (0, 255, 0),
    pygame.K_3: (255, 0, 102),
    pygame.K_4: (255, 255, 255),
    pygame.K_5: (160, 82, 45)
}

# Creazione della finestra e del clock
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Labirinto Neurale di Caterina - Cnot, capitolo 2")
clock = pygame.time.Clock()

# Profilo target e tolleranza
target_profile = {'n': 55, 'e': 60, 'ap': 80, 'am': 45, 'c': 50}
profile = target_profile.copy()
TOLERANCE = 4

# Transizioni e modifiche del profilo (rimangono invariati)
TRANSITIONS = {
    ("n", "n"): "n+",
    ("n", "e"): "n-",
    ("n", "ap"): "x",
    ("n", "am"): "x",
    ("n", "c"): "x",
    ("e", "n"): "e-",
    ("e", "e"): "x",
    ("e", "ap"): "e+",
    ("e", "am"): "x",
    ("e", "c"): "x",
    ("ap", "n"): "x",
    ("ap", "e"): "ap+",
    ("ap", "ap"): "x",
    ("ap", "am"): "x",
    ("ap", "c"): "ap-",
    ("am", "n"): "x",
    ("am", "e"): "x",
    ("am", "ap"): "am+",
    ("am", "am"): "x",
    ("am", "c"): "am-",
    ("c", "n"): "x",
    ("c", "e"): "x",
    ("c", "ap"): "x",
    ("c", "am"): "c-",
    ("c", "c"): "c+"
}

MOD_EFFECTS = {
    "x":    (0, 0, 0, 0, 0),
    "n+":   (5, 0, 0, 0, 0),
    "n-":   (-5, 0, 0, 0, 0),
    "e+":   (0, 5, 0, 0, 0),
    "e-":   (0, -5, 0, 0, 0),
    "ap+":  (0, 0, 5, 0, 0),
    "ap-":  (0, 0, -5, 0, 0),
    "am+":  (0, 0, 0, 5, 0),
    "am-":  (0, 0, 0, -5, 0),
    "c+":   (0, 0, 0, 0, 5),
    "c-":   (0, 0, 0, 0, -5),
    "+N":   (10, 0, 0, 0, 0),
    "+e+":  (0, 15, 0, 0, 0)
}

fsm_state = "n"
neuron_types = ["n", "e", "ap", "am", "c"]

# --- Struttura dei livelli ---
# Livello 0 (nodo iniziale)
level0 = [
    ("n", "Purtroppo il documento è stato cancellato per errore, quindi non posso fornirlo.",
          "Capisco, ma deve esistere una traccia nei log.")
]
# Livello 1
level1 = [
    ("n", "Non possiamo fare nulla ormai. Se il file è sparito, è colpa di un errore di sistema o di qualcuno che ha agito di nascosto. Non c'è modo di recuperarlo, temo il peggio.",
          "Cosa dovrei fare adesso?"),
    ("e", "Non perdiamo tempo! Parliamone subito con qualcuno che può aiutarci, magari scopriamo qualcosa di utile. Se restiamo bloccate a pensare, non ne veniamo fuori!",
          "Cosa dovrei fare adesso?"),
    ("ap", "E se invece guardassimo il problema da un'altra prospettiva? Forse non serve il documento originale... potremmo trovare un modo alternativo per ricostruire le informazioni!",
          "Cosa dovrei fare adesso?"),
    ("am", "Capisco quanto sia importante per te, e voglio aiutarti. Sei preoccupata? Non sei sola, possiamo affrontarlo insieme. Ti starò accanto qualsiasi cosa accada.",
          "Cosa dovrei fare adesso?"),
    ("c", "Dobbiamo ricostruire i passaggi. Se analizziamo con attenzione tutto ciò che è successo, possiamo trovare una spiegazione. Non possiamo trarre conclusioni affrettate.",
          "Cosa dovrei fare adesso?")
]
# Livello 2
level2 = [
    ("n", "Forse hai fatto qualcosa senza accorgertene… A volte si commettono errori anche senza intenzione. E se fossi stata tu a causarlo senza volerlo?",
          "Non ho capito qual è stato il mio errore. Come ho provocato questo?"),
    ("e", "Non pensiamo agli errori! L'importante è agire subito. Dobbiamo muoverci ora per rimediare, senza perdere tempo in dettagli inutili!",
          "Non ho capito qual è stato il mio errore. Come ho provocato questo?"),
    ("ap", "Forse il vero errore è pensare che ci sia stato un errore. Se tutto è relativo, anche il problema potrebbe essere solo un punto di vista. Non credi?",
          "Non ho capito qual è stato il mio errore. Come ho provocato questo?"),
    ("am", "Non preoccuparti, non è colpa tua. Sei una persona attenta e capace. Troveremo insieme un modo per capire cosa è successo.",
          "Non ho capito qual è stato il mio errore. Come ho provocato questo?"),
    ("c", "L’errore può essere stato nel processo, non in te. Dobbiamo analizzare ogni passaggio e capire dove il sistema ha fallito. Vediamo i dati.",
          "Non ho capito qual è stato il mio errore. Come ho provocato questo?")
]
# Livello 3
level3 = [
    ("n", "Lo so, mi dispiace... Ma ho paura di fare ancora più danni se cerchiamo di rimediare. E se peggiorassimo la situazione?",
          "Non possiamo ripetere il colloquio con la PzIA per avere un nuovo documento valutativo?"),
    ("e", "Non pensarci troppo! Dobbiamo agire subito. Io direi di bypassare il sistema e risolvere la questione con la PzIA in modo diretto. Basta aspettare!",
          "Non possiamo ripetere il colloquio con la PzIA per avere un nuovo documento valutativo?"),
    ("ap", "Forse il problema è più profondo. Dovremmo chiederci se il documento abbia davvero valore. Non è forse un’occasione per ridefinire tutto il processo?",
          "Non possiamo ripetere il colloquio con la PzIA per avere un nuovo documento valutativo?"),
    ("am", "Capisco che ti senti frustrata, e non voglio che tu ti senta sola in questa situazione. Ti prometto che faremo il possibile per trovare una soluzione insieme.",
          "Non possiamo ripetere il colloquio con la PzIA per avere un nuovo documento valutativo?"),
    ("c", "Dobbiamo seguire il protocollo. Il problema è stato registrato, quindi dobbiamo prima presentare una richiesta ufficiale e aspettare la risposta.",
          "Non possiamo ripetere il colloquio con la PzIA per avere un nuovo documento valutativo?")
]
# Livello 4
level4 = [
    ("n", "L’unico modo per evitare ulteriori problemi è che tu riveda il colloquio esattamente com'è avvenuto. Indossa gli Oculus e potrai vedere con i tuoi occhi!",
          "Va bene, farò come mi chiedi."),
    ("e", "Grande idea! Guarda, ho già preparato gli Oculus per te. Indossali e tutto sarà chiaro, vedrai subito cosa è successo!",
          "Va bene, farò come mi chiedi."),
    ("ap", "Metterti gli Oculus potrebbe offrirti una nuova prospettiva. Non è affascinante poter rivivere l'intero colloquio in prima persona? Forse scoprirai dettagli che prima ti sfuggivano.",
          "Va bene, farò come mi chiedi."),
    ("am", "So che tutto questo è difficile per te, ma fidati di me. Voglio solo aiutarti. Indossa gli Oculus e vedrai che insieme capiremo tutto.",
          "Va bene, farò come mi chiedi."),
    ("c", "È il procedimento standard. Il sistema prevede che in caso di smarrimento dei dati, si acceda alla registrazione originale tramite Oculus. Indossali e potremo procedere.",
          "Va bene, farò come mi chiedi.")
]

# Raggruppa i livelli in una lista (i livelli da 0 a 4)
levels = [level0, level1, level2, level3, level4]
num_levels = len(levels)

# --- Classe Node ---
class Node:
    def __init__(self, node_id, x, y, neuron_type, dialogue):
        self.id = node_id
        self.x = x
        self.y = y
        self.neuron_type = neuron_type  # "n", "e", "ap", "am", "c"
        self.dialogue = dialogue        # Dizionario con chiavi "eva" e "caterina"
        self.neighbors = []             # Qui saranno assegnati i nodi del livello successivo (o l'Oculus)

    def draw(self, surface, is_current=False, is_goal=False):
        color = GOAL_COLOR if is_goal else (NEURON_COLOR if not is_current else (0, 255, 0))
        pygame.draw.circle(surface, color, (int(self.x), int(self.y)), 15)
        font = pygame.font.SysFont(None, 20)
        if is_goal:
            text = font.render("Oculus", True, TEXT_COLOR)
        else:
            text = font.render(self.neuron_type, True, TEXT_COLOR)
        text_rect = text.get_rect(center=(self.x, self.y))
        surface.blit(text, text_rect)

# --- Generazione dei nodi con posizionamento per livello ---
all_nodes = []
levels_nodes = []  # Lista di liste: ogni sottolista contiene i nodi di quel livello
node_id_counter = 0

for i, level in enumerate(levels):
    level_nodes = []
    # Calcola la coordinata y per questo livello (da level 0 a level num_levels-1)
    y = margin_y_top + (region_height / (num_levels - 1)) * i
    n_nodes = len(level)
    for j, dialogue in enumerate(level):
        # Se c'è un solo nodo (livello 0) centrato, altrimenti distribuisci orizzontalmente
        if n_nodes == 1:
            x = WIDTH / 2
        else:
            x = margin_x + (j + 0.5) * (level_width / n_nodes)
        dim, eva_text, cat_text = dialogue
        node = Node(node_id_counter, x, y, dim, {"eva": eva_text, "caterina": cat_text})
        level_nodes.append(node)
        all_nodes.append(node)
        node_id_counter += 1
    levels_nodes.append(level_nodes)

# --- Nodo Oculus (Goal) ---
# Posizionamento: in alto a destra, ad esempio al centro orizzontale dell'ultimo livello
oculus_y = margin_y_top + region_height  # stesso y del livello 4
oculus_x = WIDTH - margin_x / 2
oculus_node = Node(node_id_counter, oculus_x, oculus_y, "Oculus", {"eva": "Oculus", "caterina": ""})
all_nodes.append(oculus_node)
node_id_counter += 1

# --- Assegnazione dei collegamenti ---
# Per ogni livello (eccetto l'ultimo) collega ogni nodo a tutti i nodi del livello successivo
for i in range(len(levels_nodes) - 1):
    for node in levels_nodes[i]:
        for next_node in levels_nodes[i + 1]:
            node.neighbors.append(next_node)
# Per ogni nodo dell'ultimo livello (livello 4) aggiungi il nodo Oculus
for node in levels_nodes[-1]:
    node.neighbors.append(oculus_node)

# --- Funzioni di utilità (già presenti) ---
def sign(x):
    return 1 if x > 0 else (-1 if x < 0 else 0)

def rotate_vector(vec, angle):
    cos_a = math.cos(angle)
    sin_a = math.sin(angle)
    return (vec[0]*cos_a - vec[1]*sin_a, vec[0]*sin_a + vec[1]*cos_a)

def draw_curved_edge_with_control(surface, start, end, control, blink_factor):
    points = []
    for t in range(21):
        t_norm = t / 20
        x = (1 - t_norm)**2 * start[0] + 2 * (1 - t_norm) * t_norm * control[0] + t_norm**2 * end[0]
        y = (1 - t_norm)**2 * start[1] + 2 * (1 - t_norm) * t_norm * control[1] + t_norm**2 * end[1]
        points.append((x, y))
    color = (int(BLINK_BASE[0]*blink_factor),
             int(BLINK_BASE[1]*blink_factor),
             int(BLINK_BASE[2]*blink_factor))
    pygame.draw.lines(surface, color, False, points, 2)

def draw_curved_edge(surface, start, end, blink_factor, color_override=None):
    mid_x = (start[0] + end[0]) / 2
    mid_y = (start[1] + end[1]) / 2
    dx = end[0] - start[0]
    dy = end[1] - start[1]
    length = math.hypot(dx, dy)
    if length == 0:
        length = 1
    offset = 30
    perp_x = -dy / length * offset
    perp_y = dx / length * offset
    control = (mid_x + perp_x, mid_y + perp_y)
    points = []
    for t in range(21):
        t_norm = t / 20
        x = (1 - t_norm)**2 * start[0] + 2*(1 - t_norm)*t_norm * control[0] + t_norm**2 * end[0]
        y = (1 - t_norm)**2 * start[1] + 2*(1 - t_norm)*t_norm * control[1] + t_norm**2 * end[1]
        points.append((x, y))
    if color_override is not None:
        color = (int(color_override[0]*blink_factor),
                 int(color_override[1]*blink_factor),
                 int(color_override[2]*blink_factor))
    else:
        color = (int(BLINK_BASE[0]*blink_factor),
                 int(BLINK_BASE[1]*blink_factor),
                 int(BLINK_BASE[2]*blink_factor))
    pygame.draw.lines(surface, color, False, points, 3)

def draw_edges(surface, blink_factor):
    drawn = set()
    for node in all_nodes:
        for neighbor in node.neighbors:
            if (node.id, neighbor.id) not in drawn and (neighbor.id, node.id) not in drawn:
                start = (node.x, node.y)
                end = (neighbor.x, neighbor.y)
                draw_curved_edge(surface, start, end, blink_factor)
                drawn.add((node.id, neighbor.id))

def draw_profile(surface):
    bar_width = 20
    spacing = 10
    x_start = 0
    y_base = HEIGHT - 50
    font = pygame.font.SysFont(None, 24)
    dims = ['n', 'e', 'ap', 'am', 'c']
    for i, d in enumerate(dims):
        value = profile[d]
        target = target_profile[d]
        if value < target:
            bar_color = (135, 206, 250)
        elif value > target:
            bar_color = (255, 0, 0)
        else:
            bar_color = (0, 255, 0)
        bar_height = value * 2
        x = x_start + i*(bar_width+spacing)
        y = y_base - bar_height
        pygame.draw.rect(surface, bar_color, (x, y, bar_width, bar_height))
        label = font.render(d, True, TEXT_COLOR)
        label_rect = label.get_rect(center=(x+bar_width//2, y_base+15))
        surface.blit(label, label_rect)

def check_profile():
    for d in profile:
        if abs(profile[d]-target_profile[d]) > TOLERANCE:
            return False
    return True

def reset_game():
    global profile, current_node, fsm_state, start_ticks, game_over, victory, prev_tick_second
    profile = target_profile.copy()
    current_node = levels_nodes[0][0]  # Nodo iniziale
    fsm_state = "n"
    start_ticks = pygame.time.get_ticks()
    prev_tick_second = int(game_duration)
    game_over = False
    victory = False

game_duration = 180
start_ticks = pygame.time.get_ticks()
prev_tick_second = int(game_duration)

# Mappatura dei tasti per la navigazione tra i nodi del livello successivo (1-4)
arrow_mapping = {
    pygame.K_1: 0,
    pygame.K_2: 1,
    pygame.K_3: 2,
    pygame.K_4: 3
}

# Finestra di introduzione e spiegazione (invariata)
def show_intro():
    intro_font = pygame.font.SysFont(None, 72)
    intro_text = intro_font.render("Cnot, capitolo 2", True, TEXT_COLOR)
    sub_font = pygame.font.SysFont(None, 36)
    lore_lines = [
        "In un futuro distopico, la mente umana e l'intelligenza artificiale",
        "si fondono in una realtà dove i ricordi e le emozioni sono in bilico.",
        "Caterina, la nostra eroina, deve attraversare un labirinto neurale,",
        "un reame di connessioni e decisioni critiche, per salvare la propria identità",
        "e impedire che forze oscure alterino il suo destino.",
        "Preparati a immergerti in Cnot, capitolo 2..."
    ]
    screen.fill(BLACK)
    intro_rect = intro_text.get_rect(center=(WIDTH//2, HEIGHT//2-150))
    screen.blit(intro_text, intro_rect)
    for i, line in enumerate(lore_lines):
        line_text = sub_font.render(line, True, TEXT_COLOR)
        line_rect = line_text.get_rect(center=(WIDTH//2, HEIGHT//2-50+i*40))
        screen.blit(line_text, line_rect)
    prompt_text = sub_font.render("Premi un tasto per continuare", True, TEXT_COLOR)
    prompt_rect = prompt_text.get_rect(center=(WIDTH//2, HEIGHT//2+150))
    screen.blit(prompt_text, prompt_rect)
    pygame.display.flip()
    waiting = True
    while waiting:
        for event in pygame.event.get():
            if event.type==pygame.QUIT:
                pygame.quit(); sys.exit()
            if event.type==pygame.KEYDOWN:
                waiting = False

def show_explanation():
    exp_font = pygame.font.SysFont(None, 48)
    exp_text = exp_font.render("Spiegazione Biologica", True, TEXT_COLOR)
    sub_font = pygame.font.SysFont(None, 28)
    explanation_lines = [
        "Il profilo psicologico di Caterina è definito dai valori di:",
        "Neuroticismo, Estroversione, Apertura, Amicalità e Coscienziosità.",
        "Le scelte in questo grafo aumentano o diminuiscono questi tratti.",
        "Ogni spostamento potrebbe modificare il profilo.",
        "Conduci Caterina ad indossare gli Oculus mantenendo il suo profilo NEO PI-R",
        "come si presenta all'inizio della conversazione."
    ]
    screen.fill(BLACK)
    exp_rect = exp_text.get_rect(center=(WIDTH//2, HEIGHT//2-200))
    screen.blit(exp_text, exp_rect)
    for i, line in enumerate(explanation_lines):
        line_text = sub_font.render(line, True, TEXT_COLOR)
        line_rect = line_text.get_rect(center=(WIDTH//2, HEIGHT//2-100+i*35))
        screen.blit(line_text, line_rect)
    prompt_text = sub_font.render("Premi un tasto per iniziare il gioco", True, TEXT_COLOR)
    prompt_rect = prompt_text.get_rect(center=(WIDTH//2, HEIGHT-100))
    screen.blit(prompt_text, prompt_rect)
    pygame.display.flip()
    waiting = True
    while waiting:
        for event in pygame.event.get():
            if event.type==pygame.QUIT:
                pygame.quit(); sys.exit()
            if event.type==pygame.KEYDOWN:
                waiting = False

# Visualizza le schermate introduttive
show_intro()
show_explanation()
# Mostra una finestra di transizione (facoltativa)
def show_transition_diagram_placeholder():
    # Puoi mantenere questa funzione per mostrare una breve animazione o diagramma
    start_time = pygame.time.get_ticks()
    while pygame.time.get_ticks() - start_time < 2000:
        for event in pygame.event.get():
            if event.type==pygame.QUIT:
                pygame.quit(); sys.exit()
        screen.fill(BLACK)
        pygame.display.flip()
        clock.tick(FPS)
show_transition_diagram_placeholder()

# Imposta il nodo corrente (iniziale)
current_node = levels_nodes[0][0]

game_over = False
victory = False

# Funzione per disegnare una finestra di dialogo fissa (300px di larghezza) a sinistra
def draw_dialogue_window(surface, current_node):
    panel_width = 300
    panel_height = 200
    panel_x = 200   # Puoi modificare la posizione orizzontale se desideri
    panel_y = HEIGHT - (panel_height + 50)
    pygame.draw.rect(surface, (30,30,30), (panel_x, panel_y, panel_width, panel_height))
    pygame.draw.rect(surface, WHITE, (panel_x, panel_y, panel_width, panel_height), 2)
    
    font = pygame.font.SysFont(None, 20)
    small_font = pygame.font.SysFont(None, 18)
    y_offset = panel_y + 10
    max_text_width = panel_width - 20

    # Nodo attivo (senza titolo, mostriamo solo il dialogo)
    active_eva = "Eva: " + current_node.dialogue["eva"]
    active_cat = "Cat: " + current_node.dialogue["caterina"]
    # Se necessario, potresti aggiungere wrapping qui (ad es. usando una funzione draw_text_wrapped)
    surface.blit(font.render(active_eva, True, WHITE), (panel_x + 10, y_offset))
    y_offset += font.get_linesize() + 2
    surface.blit(font.render(active_cat, True, WHITE), (panel_x + 10, y_offset))
    y_offset += font.get_linesize() + 15

    # Nodi collegati (mostriamo fino a 4 o 5, in base alla mappatura dei tasti)
    legend_keys = ["1", "2", "3", "4", "5"]
    key_color_map = {
        "1": arrow_colors[pygame.K_1],
        "2": arrow_colors[pygame.K_2],
        "3": arrow_colors[pygame.K_3],
        "4": arrow_colors[pygame.K_4],
        "5": arrow_colors[pygame.K_5]
    }
    for i, key in enumerate(legend_keys):
        if i < len(current_node.neighbors):
            neighbor = current_node.neighbors[i]
            key_text = small_font.render(key + ":", True, key_color_map[key])
            surface.blit(key_text, (panel_x + 10, y_offset))
            y_offset += small_font.get_linesize()
            eva_line = "Eva: " + neighbor.dialogue["eva"]
            cat_line = "Cat: " + neighbor.dialogue["caterina"]
            surface.blit(small_font.render(eva_line, True, WHITE), (panel_x + 40, y_offset))
            y_offset += small_font.get_linesize() + 2
            surface.blit(small_font.render(cat_line, True, WHITE), (panel_x + 40, y_offset))
            y_offset += small_font.get_linesize() + 10

# Loop principale del gioco
while True:
    dt = clock.tick(FPS) / 1000.0
    blink_factor = 0.75 + 0.25 * math.sin(pygame.time.get_ticks()*0.005)
    
    for event in pygame.event.get():
        if event.type==pygame.QUIT:
            pygame.quit(); sys.exit()
        if not game_over:
            if event.type==pygame.KEYDOWN:
                if event.key in arrow_mapping:
                    index = arrow_mapping[event.key]
                    # Se il nodo attivo ha un vicino con quell'indice, passa al prossimo livello
                    if index < len(current_node.neighbors):
                        next_node = current_node.neighbors[index]
                        # Aggiorna il profilo in base alla transizione (uso della funzione già definita)
                        if next_node == oculus_node:
                            update_profile_fsm_neutral("X")
                        else:
                            update_profile_fsm(next_node.neuron_type)
                        current_node = next_node
                        if node_sound is not None:
                            node_sound.play()
                        # Se il nodo corrente è l'Oculus, controlla il profilo
                        if current_node == oculus_node:
                            if check_profile():
                                game_over = True
                                victory = True
                            else:
                                game_over = True
                                victory = False
        elif game_over:
            if event.type==pygame.KEYDOWN:
                if event.key == pygame.K_r:
                    reset_game()
    
    seconds_elapsed = (pygame.time.get_ticks()-start_ticks)/1000
    time_remaining = game_duration - seconds_elapsed
    current_tick_second = int(time_remaining)
    # (Gestione del timer con suono per tick, ecc.)
    if time_remaining <= 0 and not game_over:
        game_over = True
        victory = False

    screen.fill(BLACK)
    draw_edges(screen, blink_factor)
    
    for key, idx in arrow_mapping.items():
        if idx < len(current_node.neighbors):
            neighbor = current_node.neighbors[idx]
            draw_curved_edge(screen, (current_node.x, current_node.y), (neighbor.x, neighbor.y),
                             blink_factor, color_override=arrow_colors[key])
    
    for node in all_nodes:
        is_current = (node == current_node)
        is_goal = (node == oculus_node)
        node.draw(screen, is_current, is_goal)
    
    draw_profile(screen)
    
    font_timer = pygame.font.SysFont(None, 28)
    timer_text = font_timer.render(f"Tempo: {int(time_remaining)} s", True, WHITE)
    screen.blit(timer_text, (20, 20))
    
    # Disegna la finestra di dialogo fissa a sinistra
    draw_dialogue_window(screen, current_node)
    
    if game_over:
        font_big = pygame.font.SysFont(None, 48)
        msg = "VITTORIA!" if victory else "GAME OVER: Profilo errato! Premi R per riprovare"
        text = font_big.render(msg, True, (255, 0, 0))
        text_rect = text.get_rect(center=(WIDTH//2, 50))
        screen.blit(text, text_rect)
    
    pygame.display.flip()
