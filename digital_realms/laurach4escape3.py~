import pygame
import random
import math

# Inizializza Pygame
pygame.init()

# Imposta dimensioni della finestra
WIDTH, HEIGHT = 800, 600
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Quantum Tunnel Chase: Reach Caterina!")

# Colori
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
CYAN = (0, 255, 255)
GRAY = (150, 150, 150)
RED = (255, 0, 0)
YELLOW = (255, 255, 0)
COLORS = [(255, 0, 0), (0, 255, 0), (0, 0, 255), (255, 255, 0), (0, 255, 255)]

# Font per punteggio e messaggi
pygame.font.init()
font = pygame.font.Font(None, 50)

# Drone - Molecola di CH4
drone_radius = 50
drone_center = [WIDTH // 2, HEIGHT - 100]  # Posizione iniziale in basso al centro
drone_speed_x = 6  # Velocità orizzontale
drone_speed_y = 6  # Velocità verticale
rotation_angle = 0  # Angolo iniziale per la rotazione

# Secondo drone (agente)
agent_radius = 50
agent_center = [WIDTH // 4, 100]  # Posizione iniziale in alto
agent_speed = 2  # Velocità ridotta
agent_rotation_angle = 0  # Angolo iniziale per la rotazione
agent_active = True  # Stato del drone agente
agent_respawn_timer = 0  # Timer per il respawn del drone agente

# Qubit
qubit_radius = 15
qubits = []  # Lista per i qubit (posizione x, posizione y, angolo di rotazione)
qubit_speed = 4  # Velocità verticale dei qubit
spawn_rate = 30  # Ogni quanti frame aggiungere un nuovo qubit
frame_count = 0

# Caterina
caterina_radius = 25
caterina_position = None  # Posizione di Caterina
caterina_timer = 0  # Timer per la permanenza di Caterina
caterina_visible = False  # Stato di Caterina
caterina_spawn_delay = 500  # Ritardo in frame prima della prossima comparsa

# Griglia scorrevole
grid_offset = 0
grid_speed = 2

# Controllo continuo
move_left = False
move_right = False
move_up = False
move_down = False

# Game state
game_over = False
score = 0  # Punteggio iniziale

# Funzione per disegnare Caterina
def draw_caterina():
    if caterina_visible and caterina_position:
        pygame.draw.circle(screen, YELLOW, caterina_position, caterina_radius)

# Funzione per aggiornare Caterina
def update_caterina():
    global caterina_visible, caterina_position, caterina_timer, caterina_spawn_delay, score
    if caterina_visible:
        # Riduci il timer per la permanenza
        caterina_timer -= 1
        if caterina_timer <= 0:
            caterina_visible = False
    else:
        # Riduci il timer per il prossimo spawn
        caterina_spawn_delay -= 1
        if caterina_spawn_delay <= 0:
            caterina_position = [random.randint(caterina_radius, WIDTH - caterina_radius), random.randint(caterina_radius, HEIGHT // 2)]
            caterina_visible = True
            caterina_timer = 300  # Resta visibile per 300 frame
            caterina_spawn_delay = 500  # Aspetta altri 500 frame per riapparire

    # Controlla se Laura raggiunge Caterina
    if caterina_visible and math.hypot(caterina_position[0] - drone_center[0], caterina_position[1] - drone_center[1]) < caterina_radius + 12:
        caterina_visible = False
        score += 500  # Bonus punteggio

# Funzione per disegnare la griglia
def draw_grid():
    global grid_offset
    for x in range(0, WIDTH, 40):
        for y in range(-40, HEIGHT, 40):
            pygame.draw.rect(screen, random.choice(COLORS), (x, y + grid_offset, 40, 40), 1)
    grid_offset = (grid_offset + grid_speed) % 40

# Funzione per disegnare il punteggio
def draw_score():
    score_text = font.render(f"Score: {score}", True, WHITE)
    screen.blit(score_text, (10, 10))

# Ciclo principale
clock = pygame.time.Clock()
while not game_over:
    screen.fill(BLACK)
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            game_over = True
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_LEFT:
                move_left = True
            elif event.key == pygame.K_RIGHT:
                move_right = True
            elif event.key == pygame.K_UP:
                move_up = True
            elif event.key == pygame.K_DOWN:
                move_down = True
        elif event.type == pygame.KEYUP:
            if event.key == pygame.K_LEFT:
                move_left = False
            elif event.key == pygame.K_RIGHT:
                move_right = False
            elif event.key == pygame.K_UP:
                move_up = False
            elif event.key == pygame.K_DOWN:
                move_down = False

    # Movimento del drone di Laura
    if move_left:
        drone_center[0] = max(drone_center[0] - drone_speed_x, drone_radius)
    if move_right:
        drone_center[0] = min(drone_center[0] + drone_speed_x, WIDTH - drone_radius)
    if move_up:
        drone_center[1] = max(drone_center[1] - drone_speed_y, drone_radius)
    if move_down:
        drone_center[1] = min(drone_center[1] + drone_speed_y, HEIGHT - drone_radius)

    # Movimento del drone agente
    if agent_active:
        if agent_center[0] < drone_center[0]:
            agent_center[0] += agent_speed
        elif agent_center[0] > drone_center[0]:
            agent_center[0] -= agent_speed
        if agent_center[1] < drone_center[1]:
            agent_center[1] += agent_speed
        elif agent_center[1] > drone_center[1]:
            agent_center[1] -= agent_speed
    elif agent_respawn_timer > 0:
        agent_respawn_timer -= 1
        if agent_respawn_timer == 0:
            agent_center = [random.randint(50, WIDTH - 50), 100]
            agent_active = True

    # Disegna tutto
    draw_grid()
    draw_drone(drone_center, GRAY, rotation_angle)
    if agent_active:
        draw_drone(agent_center, RED, agent_rotation_angle)
    draw_qubits()
    draw_score()
    draw_caterina()

    # Aggiorna qubits e spawna nuovi
    frame_count += 1
    if frame_count % spawn_rate == 0:
        qubits.append([random.randint(0, WIDTH), -20, random.randint(0, 360)])
    update_qubits()
    update_caterina()

    # Aggiorna schermo
    pygame.display.flip()
    clock.tick(30)

pygame.quit()
