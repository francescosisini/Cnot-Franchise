import pygame
import random
import math

# Inizializza Pygame
pygame.init()

# Imposta dimensioni della finestra
WIDTH, HEIGHT = 800, 600
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Quantum Tunnel Chase with Caterina")

# Colori
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
CYAN = (0, 255, 255)
GRAY = (150, 150, 150)
RED = (255, 0, 0)
MAGENTA = (255, 0, 255)
COLORS = [(255, 0, 0), (0, 255, 0), (0, 0, 255), (255, 255, 0), (0, 255, 255)]

# Font per punteggio e messaggi
pygame.font.init()
font = pygame.font.Font(None, 50)
message_font = pygame.font.Font(None, 74)

# Drone - Molecola di CH4
drone_radius = 50
drone_center = [WIDTH // 2, HEIGHT - 100]
drone_speed_x = 6
drone_speed_y = 6
rotation_angle = 0

# Secondo drone (agente)
agent_radius = 50
agent_center = [WIDTH // 4, 100]
agent_speed = 2
agent_rotation_angle = 0
agent_active = True
agent_respawn_timer = 0

# Qubit
qubit_radius = 15
qubits = []
qubit_speed = 4
spawn_rate = 30
frame_count = 0

# Caterina
caterina_radius = 25
caterina_spawned = False
caterina_position = [random.randint(50, WIDTH - 50), random.randint(50, HEIGHT // 2)]
caterina_timer = 200  # Tempo limite per Caterina
caterina_teleport_timer = 60  # Timer per cambio posizione

# Griglia scorrevole
grid_offset = 0
grid_speed = 2

# Controllo continuo
move_left = False
move_right = False
move_up = False
move_down = False

# Game state
game_over = False
score = 0
victory = False

# Funzione per disegnare il drone CH4
def draw_drone(center, color, rotation_angle):
    pygame.draw.circle(screen, color, center, 12)
    for i in range(4):
        angle = i * (360 // 4) + rotation_angle
        dx = drone_radius * math.cos(math.radians(angle))
        dy = drone_radius * math.sin(math.radians(angle))
        pygame.draw.circle(screen, CYAN, (int(center[0] + dx), int(center[1] + dy)), 8)

# Funzione per disegnare i qubit come triangoli rotanti
def draw_qubits():
    for qubit in qubits:
        x, y, angle = qubit
        points = [
            (x + qubit_radius * math.cos(math.radians(angle)), y + qubit_radius * math.sin(math.radians(angle))),
            (x + qubit_radius * math.cos(math.radians(angle + 120)), y + qubit_radius * math.sin(math.radians(angle + 120))),
            (x + qubit_radius * math.cos(math.radians(angle + 240)), y + qubit_radius * math.sin(math.radians(angle + 240)))
        ]
        pygame.draw.polygon(screen, WHITE, points)

# Funzione per aggiornare la posizione dei qubit
def update_qubits():
    global game_over, agent_active, score, agent_respawn_timer
    for qubit in qubits:
        qubit[1] += qubit_speed
        qubit[2] = (qubit[2] + 5) % 360
        if qubit[1] > HEIGHT:
            qubits.remove(qubit)
        if math.hypot(qubit[0] - drone_center[0], qubit[1] - drone_center[1]) < qubit_radius + 12:
            game_over = True
        if agent_active and math.hypot(qubit[0] - agent_center[0], qubit[1] - agent_center[1]) < qubit_radius + 12:
            agent_active = False
            agent_respawn_timer = 180
            score += 100

# Funzione per disegnare Caterina
def draw_caterina():
    if caterina_spawned:
        pygame.draw.circle(screen, MAGENTA, caterina_position, caterina_radius)
        pygame.draw.circle(screen, WHITE, caterina_position, caterina_radius + 5, 2)

# Funzione per controllare la collisione con Caterina
def check_caterina_collision():
    global caterina_spawned, score, caterina_timer, victory
    if caterina_spawned and math.hypot(caterina_position[0] - drone_center[0], caterina_position[1] - drone_center[1]) < drone_radius + caterina_radius:
        caterina_spawned = False
        victory = True  # Vittoria

# Funzione per disegnare la griglia
def draw_grid():
    global grid_offset
    for x in range(0, WIDTH, 40):
        for y in range(-40, HEIGHT, 40):
            pygame.draw.rect(screen, random.choice(COLORS), (x, y + grid_offset, 40, 40), 1)
    grid_offset = (grid_offset + grid_speed) % 40

# Funzione per disegnare il punteggio
def draw_score():
    score_text = font.render(f"Score: {score}", True, WHITE)
    screen.blit(score_text, (10, 10))

# Ciclo principale
clock = pygame.time.Clock()
while not game_over and not victory:
    screen.fill(BLACK)
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            game_over = True
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_LEFT:
                move_left = True
            elif event.key == pygame.K_RIGHT:
                move_right = True
            elif event.key == pygame.K_UP:
                move_up = True
            elif event.key == pygame.K_DOWN:
                move_down = True
        elif event.type == pygame.KEYUP:
            if event.key == pygame.K_LEFT:
                move_left = False
            elif event.key == pygame.K_RIGHT:
                move_right = False
            elif event.key == pygame.K_UP:
                move_up = False
            elif event.key == pygame.K_DOWN:
                move_down = False

    # Movimento del drone di Laura
    if move_left:
        drone_center[0] = max(drone_center[0] - drone_speed_x, drone_radius)
    if move_right:
        drone_center[0] = min(drone_center[0] + drone_speed_x, WIDTH - drone_radius)
    if move_up:
        drone_center[1] = max(drone_center[1] - drone_speed_y, drone_radius)
    if move_down:
        drone_center[1] = min(drone_center[1] + drone_speed_y, HEIGHT - drone_radius)

    # Spawna Caterina
    if not caterina_spawned and random.randint(0, 500) == 0:
        caterina_spawned = True
        caterina_position = [random.randint(50, WIDTH - 50), random.randint(50, HEIGHT // 2)]

    # Movimento e controllo di Caterina
    if caterina_spawned:
        caterina_timer -= 1
        if caterina_timer <= 0:
            caterina_spawned = False
            caterina_timer = 200  # Reset timer

    # Disegna tutto
    draw_grid()
    draw_drone(drone_center, GRAY, rotation_angle)
    if agent_active:
        draw_drone(agent_center, RED, agent_rotation_angle)
    draw_qubits()
    draw_caterina()
    draw_score()

    # Controlli collisioni
    update_qubits()
    check_caterina_collision()

    # Aggiorna schermo
    pygame.display.flip()
    clock.tick(30)

# Messaggio finale
screen.fill(BLACK)
message = "Victory!" if victory else "Game Over!"
message_surface = message_font.render(message, True, WHITE)
screen.blit(message_surface, (WIDTH // 2 - message_surface.get_width() // 2, HEIGHT // 2))
pygame.display.flip()
pygame.time.wait(3000)

pygame.quit()
